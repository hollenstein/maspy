from __future__ import print_function

import csv
import itertools
import os
import re

import numpy
import pymzml
import pyteomics.fasta

import maspy.auxiliary as aux
import maspy.constants
import maspy.core
import maspy.peptidemethods


# --- import for SiContainer class --- #
def pymzmlReadMzml(mzmlPath, mzmlAccessions):
    """Auxiliary function to specify extra accesions when reading an mzml file with :func:`pymzml.run.Reader`.

    :ivar mzmlPath: File path
    :ivar mzmlAccessions: a diciontary describing the attributes that will be extracted from the mzml file, see: :func:`importSpectrumItems`.
    """
    extraAccessions = list()
    for accessionId in mzmlAccessions.keys():
        extraAccessions.append((accessionId, ['value', 'unitName']))
    return pymzml.run.Reader(mzmlPath, extraAccessions=extraAccessions)


def importSpectrumItems(siContainer, specfilePath, specfile, msLevel=[1, 2], importIonList=True,
                        mgfType=None, mzmlAccessions=None):
    """ Import spectra from mzml or mgf files.

    :param siContainer: Spectra are added to to this instance of :class:`SiContainer`
    :param specfilePath: Actual file path (file type has to be .mzml or .mgf)
    :param specfile: Keyword (filename) to represent file in the :class:`SiContainer`. Each filename
    can only occure once, therefore importing the same filename again is prevented
    :param importIonList: bool if ion arrays (mz and intensity) should be imported
    :param mgfType: if the file is of type '.mgf', and the mgf was generated by pParse set to
    mgfType="pParse" because of header information ambiguity.
    :param mzmlAccessions: A diciontary describing the attributes that will be extracted from the mzml file.
    {MS:accessionId:{'name':the si attribute name, 'msLevel':ms level or None}, ...}
    If 'msLevel' is None the attribute is added to every SI, by specifying a number the attribute
    is only added to SI of this msLevel.
    """
    if specfilePath is None:
        raise Exception('SpecfilePath not specified, maspy.core.importSpectrumItems()') #TODO
    if not os.path.isfile(specfilePath):
        print('File does not exits:', specfilePath)
    elif not specfilePath.lower().endswith('.mzml') and not specfilePath.lower().endswith('.mgf'):
        print('File is not an "mzml" or "mgf" file:', specfilePath)
    else:
        if specfile not in siContainer.specfiles:
            siContainer.specfiles.append(specfile)
            siContainer.container[specfile] = list()
            if specfilePath.lower().endswith('.mzml'):
                #If no mzmlAccession dictionary is specified, the standard dict from maspy.auxiliary is used
                mzmlAccessions = mzmlAccessions if mzmlAccessions is not None else maspy.constants.mzmlAccessions
                msrun = pymzmlReadMzml(specfilePath, mzmlAccessions)
                importMzmlSpectrumItems(siContainer, msrun, specfile, mzmlAccessions, importIonList=importIonList)
            elif specfilePath.lower().endswith('.mgf'):
                importMgfSpectrumItems(siContainer, specfilePath, specfile, importIonList=importIonList, mgfType=mgfType)
        else:
            print(specfile, 'is already present in the SiContainer, import interrupted.')


def importMzmlSpectrumItems(siContainer, msrun, specfile, mzmlAccessions, importIonList=False):
    """Import spectrum information from mzML files. Mostly used as a private function by :func:`importSpectrumItems`.

    :param siContainer: Spectra are added to this instance of :class:`SiContainer`
    :param msrun: :object:`pymzml.run.Reader` iterator for mzml spectra of the module :mod:`pymzml`
    :param specfile: Keyword (filename) to represent file in the :class:`SiContainer`
    :param importIonList: bool if ion arrays (mz and intensity) should be imported
    """
    def _generateSpectrumItem(spectrum):
        si = maspy.core.SpectrumItem(str(spectrum['id']), specfile)
        si.msLevel = spectrum['ms level']
        si.isValid = True
        for accessionId, accessionInfo in mzmlAccessions.items():
            if accessionInfo['msLevel'] is None or si.msLevel == accessionInfo['msLevel']:
                if accessionId in spectrum:
                    setattr(si, accessionInfo['name'], spectrum[accessionId][0])
                    if accessionInfo['name'] == 'rt':
                        #change retentiontime unit from minutes to seconds
                        if spectrum[accessionId][1] == 'minute':
                            setattr(si, accessionInfo['name'], spectrum[accessionId][0] * 60)
                else:
                    setattr(si, accessionInfo['name'], None)
        return si

    currMsnContainerIdList = list()
    for spectrum in msrun:
        if spectrum['ms level'] >= 1:
            si = _generateSpectrumItem(spectrum)
            siContainer.container[specfile].append(si)
            siContainer.index[si.containerId] = si

            if importIonList:
                siContainer.ionLists[si.containerId] = dict()
                siContainer.ionLists[si.containerId]['mz'] = numpy.array(spectrum.mz, dtype='float64')
                siContainer.ionLists[si.containerId]['i'] = numpy.array(spectrum.i, dtype='float64')

            if si.msLevel == 1:
                # Add currMsnIndexList to last ms1 entry and reset currMsnContainerIdList
                setattr(si, 'msnIdList', currMsnContainerIdList)
                currMsnContainerIdList = list()
                # Change lastMs1Item to current SpectrumItem
                lastMs1Item = si

            else:
                currMsnContainerIdList.append(si.containerId)
                setattr(si, 'ms1Id', lastMs1Item.containerId)
    setattr(lastMs1Item, 'msnIdList', currMsnContainerIdList)


def importMgfSpectrumItems(siContainer, specfilePath, specfile, importIonList=False, mgfType=None):
    """Import spectrum information from mgf files.

    Mostly used as a private function by :func:`importSpectrumItems`.

    :param siContainer: Spectra are added to this instance of :func:`SiContainer`
    :param specfilePath: Actual path to file
    :param specfile: Keyword (filename) to represent file in the :class:`SiContainer`
    :param importIonList: bool if ion arrays (mz and intensity) should be imported
    :param mgfType: If mgf was generated by pParse set to "Parse" because of header information ambiguity
    """
    def _generateSpectrumItem(mgfEntry):
        mgfEntry = mgfEntry.replace('END IONS','').strip()
        ionList = list()
        ionPos = False
        attributes = dict()
        for line in mgfEntry.split('\n'):
            if ionPos:
                ionList.append(line)
            elif line[0] not in ['0','1','2','3','4','5','6','7','8','9']:
                key = line.split('=')[0].lower()
                value = line.split('=')[1]
                attributes[key] = value
            else:
                if importIonList:
                    ionPos = True
                    ionList.append(line)
                else:
                    break

        # Read scanNr from various mgf formats #
        if mgfType == 'pParse':
            nativeScanNr = attributes['title'].split('.')[1]
            scanNrExtension = attributes['title'].split('.')[4]
            scanNr = nativeScanNr+'.'+scanNrExtension
        elif 'SCANS' in attributes:
            scanNr = attributes['scans']
        else:
            scanNr = attributes['title'].split('.')[1]

        si = SpectrumItem(str(scanNr), specfile)
        si.msLevel = 2
        si.isValid = True
        si.charge = int(attributes['charge'].strip('+').strip('-')) if 'charge' in attributes else None
        si.obsMz = float(attributes['pepmass'].split(' ')[0]) if 'pepmass' in attributes else None
        si.rt = float(attributes['rtinseconds']) if 'rtinseconds' in attributes else None
        return si, ionList

    def _splitMgfIonList(ionList):
        mzList = list()
        iList = list()
        for ionEntry in ionList:
            ionEntry = ionEntry.split(' ')
            if len(ionEntry) == 2:
                mzList.append(ionEntry[0])
                iList.append(ionEntry[1])
        return mzList, iList

    with open(specfilePath,'rb') as mgfFile:
        mgfRead  = mgfFile.read()
        mgfSplit = mgfRead.split('BEGIN IONS\n')
        for mgfEntry in mgfSplit:
            if mgfEntry != '' and mgfEntry.find('END IONS') != -1:
                si, ionList = _generateSpectrumItem(mgfEntry)
                siContainer.container[specfile].append(si)
                siContainer.index[si.containerId] = si

                if importIonList:
                    mzList, iList = _splitMgfIonList(ionList)
                    siContainer.ionLists[si.containerId] = dict()
                    siContainer.ionLists[si.containerId]['mz'] = numpy.array(mzList, dtype='float64')
                    siContainer.ionLists[si.containerId]['i'] = numpy.array(iList, dtype='float64')


# --- Auxiliary functions for SiContainer class --- #
def importSpecfiles(specfiles, fileDirectory, importIonList=False, siContainer=None, recursive=True):
    """Auxiliary function to conveniently import a group of specfiles.

    :ivar specfiles: Filenames which should be imported
    :type specfiles: str() or [str(), str(), ...]
    :ivar fileDirectory: Filenames are searched in this folder and its folder
    :ivar bool importIonList: True if ion arrays (mz and intensity) should be imported
    :ivar siContainer: Add imported specfiles to siContainer, if None a new instance of :class:`SiContainer` is returned
    :ivar recursive: bool, specify whether subdirectories should be searched
    """
    if siContainer is None:
        siContainer = maspy.core.SiContainer()
    specfiles = aux.toList(specfiles)
    for specfile in specfiles:
        specfilePath = aux.searchFileLocation(specfile, 'sicontainer', fileDirectory, recursive=recursive)
        if specfilePath:
            fileFolder = os.path.dirname(specfilePath)
            maspy.core.addContainer(siContainer, maspy.core.SiContainer.load(fileFolder, specfile, importIonList=importIonList))
        else:
            specfilePath = aux.searchFileLocation(specfile, 'mzML', fileDirectory, recursive=recursive)
            if specfilePath is None:
                print('File not found: ', specfile)
            else:
                importSpectrumItems(siContainer, specfilePath, specfile, importIonList=importIonList)
    return siContainer


def generateSiContainerFiles(fileDirectory, report=True):
    """Generate .sicontainer and .ionlist files for all mzML files in the fileDirectory and its subfolders.

    see also :func:`removeSiContainerFiles` and :meth:`SiContainer.save`
    """
    for filePath in aux.matchingFilePaths('', fileDirectory, targetFileExtension='mzML', selector=lambda x: True):
        dotPosition = [x for x in aux.findAllSubstrings(filePath, '.')][-1]

        fileFolder = os.path.dirname(filePath)
        fileName = os.path.basename(filePath[:dotPosition])
        targetFilePath = '.'.join((filePath[:dotPosition], 'sicontainer'))
        if not os.path.isfile(targetFilePath):
            siContainer = maspy.core.SiContainer()
            importSpectrumItems(siContainer, filePath, fileName, importIonList=True)
            if report:
                print('Saving SiContainer() / ionList :', fileName)
            siContainer.save(fileFolder, fileName)


def removeSiContainerFiles(fileDirectory, report=True):
    """Remove all .sicontainer and .ionlist files in the fileDirectory and its subfolders.

    :ivar fileDirectory: target directory
    :ivar report: boolean, if True print path of removed files

    see also :func:`generateSiContainerFiles` and :meth:`SiContainer.save`
    """
    for filePath in aux.matchingFilePaths('', fileDirectory, targetFileExtension='sicontainer', selector=lambda x: True):
        os.remove(filePath)
        if report:
            print('removed:\n', filePath)
    for filePath in aux.matchingFilePaths('', fileDirectory, targetFileExtension='ionlist', selector=lambda x: True):
        os.remove(filePath)
        if report:
            print('removed:\n', filePath)


# --- import for SiiContainer class --- #
def importPsmResults(siiContainer, fileLocation, specfile, psmType='percolator', psmEngine='comet', qValue=0.01):
    """Function to control the import of PSM results into :class:`SiiContainer`.

    :ivar siiContainer: Add PSMs to this instance
    :ivar fileLocation: Actual path to file
    :ivar specfile: Keyword (filename) to represent file in the :class:`SiiContainer`.
    :ivar psmType: can be used to specify post processing tools like percolator, used to choose import function
    :ivar psmEngine: specify peptide spectrum matching engine, used to choose import function
    :ivar qValue: define a qValue cut off for valid items, could be changed to (:var:`scoreCutOff` and :var:`scoreKey`)

    See also :func:`_importPercolatorResults` and :func:`_importFromPercolatorArray`
    """
    if specfile not in siiContainer.container:
        siiContainer.container[specfile] = list()
    if specfile not in siiContainer.specfiles:
        siiContainer.specfiles.append(specfile)

    if psmType == 'percolator':
        _psmArrays = _importPercolatorResults(fileLocation, psmEngine=psmEngine)
        _importFromPercolatorArrays(siiContainer, _psmArrays, specfile, qValueCutOff=qValue)


def _importFromPercolatorArrays(siiContainer, psmArrays, specfile, qValueCutOff=None):
    """Writes :class:`SpectruIdentificationItem` into :class:`SiContainer`.

    :ivar siiContainer: Add PSMs to this instance
    :ivar psmArrays: contains PSM information, generated by :func:`_importFromPercolatorArray`
    :ivar specfile: Keyword (filename) to represent file in the :class:`SiContainer`
    :ivar qValueCutOff: define a qValue cut off for valid items

    See also :func:`importPsmResults`
    """
    sortMask = psmArrays['score'].argsort()[::-1]
    for key in psmArrays:
        psmArrays[key] = psmArrays[key][sortMask]

    for currPosition in range(0, len(psmArrays['scanNr'])):
        peptide = psmArrays['peptide'][currPosition]
        if peptide.find('.') != -1:
            peptide = peptide.split('.')[1]

        sequence = maspy.peptidemethods.removeModifications(peptide)
        scanNr = psmArrays['scanNr'][currPosition]
        qValue = psmArrays['q-value'][currPosition]
        score = psmArrays['score'][currPosition]
        psmId = psmArrays['PSMId'][currPosition]
        pep = psmArrays['posterior_error_prob'][currPosition]

        sii = maspy.core.SpectrumIdentificationItem(scanNr, specfile)
        sii.peptide = peptide
        sii.sequence = sequence
        sii.qValue = qValue
        sii.score = score
        sii.pep = pep
        sii.isValid = False

        if sii.containerId in siiContainer.index:
            siiList = siiContainer.index[sii.containerId]
            sii.rank = len(siiList) + 1
        else:
            sii.rank = 1
            siiContainer.index[sii.containerId] = list()

        if sii.rank == 1:
            if qValueCutOff is not None:
                if sii.qValue <= qValueCutOff:
                    sii.isValid = True
            else:
                sii.isValid = True

        siiContainer.index[sii.containerId].append(sii)
        siiContainer.container[specfile].append(sii)


def _importPercolatorResults(fileLocation, psmEngine=None):
    """Reads percolator PSM results from a txt file.

    :ivar fileLocation: File path
    :ivar psmEngine: Specifies the used peptide spectrum matching engine ('comet', 'msgf', 'xtandem')

    :return: {attribute:numpy.array(), attribute:numpy.array()}

    See also :func:`importPsmResults` and :func:`_importFromPercolatorArray`
    """
    #HEADERLINE: xtandem seperates proteins with ';', msgf separates proteins by a tab
    with open(fileLocation,'rb') as openFile:
        tsvreader = csv.reader(openFile, delimiter='\t')
        headerLine = tsvreader.next()
        headerDict = dict([[y,x] for (x,y) in enumerate(headerLine)])
        scanEntryList = list()
        for line in tsvreader:
            entryDict = dict()
            for headerName,headerPos in headerDict.items():
                entryDict[headerName] = line[headerPos]
            if psmEngine == 'msgf':
                entryDict['proteinIds'] = list(line[headerDict['proteinIds']:])
            elif psmEngine == 'xtandem':
                entryDict['proteinIds'] = entryDict['proteinIds'].split(';')
            scanEntryList.append(entryDict)

    scanArrDict = dict()
    for headerName in headerDict.keys():
        scanArrDict[headerName] = list()

    # Define list of headers #
    for scanEntryDict in scanEntryList:
        for headerName,entry in scanEntryDict.items():
            if headerName in ['score','q-value','posterior_error_prob']:
                scanArrDict[headerName].append( float(entry) )
            else:
                scanArrDict[headerName].append( entry )

    if psmEngine in ['comet','msgf','xtandem']:
        scanNrList = list()
        for entry in scanArrDict['PSMId']:
            if psmEngine in ['comet','msgf']:
                scanNr = entry.split('_')[-3]
            elif psmEngine in ['xtandem']:
                scanNr = entry.split('_')[-2]
            scanNrList.append( scanNr )
        scanArrDict['scanNr'] = scanNrList
    else:
        print('No valid psm engine specified, can\'t import percolator results!')

    for headerName in scanArrDict.keys():
        scanArrDict[headerName] = numpy.array(scanArrDict[headerName])
    return scanArrDict


# --- import for FeatureContainer class --- #
def importPeptideFeatures(featureContainer, filelocation, specfile):
    """ Import peptide features from a featureXml file (eg. generated by OPENMS featureFinderCentroided).

    :param featureContainer: Spectra are added to to this instance of :class:`FeatureContainer`
    :param filelocation: Actual file path
    :param specfile: Keyword (filename) to represent file in the :class:`FeatureContainer`. Each filename
    can only occure once, therefore importing the same filename again is prevented.
    """
    if not os.path.isfile(filelocation):
        print('File does not exits:', filelocation)
    elif not filelocation.lower().endswith('.featurexml'):
        print('File is not a featurexml file:', filelocation)
    else:
        if specfile not in featureContainer.specfiles:
            featureContainer.specfiles.append(specfile)
            featureContainer.container[specfile] = list()
            featureDict = _importFeatureXml(filelocation)

            for featureId, featureEntryDict in featureDict.items():
                rtArea = set()
                for convexHullEntry in featureEntryDict['convexHullDict']['0']:
                    rtArea.update([convexHullEntry[0]])

                featureItem = maspy.core.FeatureItem(featureId, specfile)
                featureItem.rt = featureEntryDict['rt']
                featureItem.rtArea = max(rtArea) - min(rtArea)
                featureItem.rtLow = min(rtArea)
                featureItem.rtHigh = max(rtArea)
                featureItem.charge = featureEntryDict['charge']
                featureItem.mz = featureEntryDict['mz']
                featureItem.mh = maspy.peptidemethods.calcMhFromMz(featureEntryDict['mz'], featureEntryDict['charge'])
                featureItem.intensity = featureEntryDict['intensity']
                featureItem.quality = featureEntryDict['overallquality']
                featureItem.isMatched = False
                featureItem.isAnnotated = False
                featureItem.isValid = True

                featureContainer.index[featureItem.containerId] = featureItem
                featureContainer.container[specfile].append(featureItem)
        else:
            print(specfile, 'is already present in the SiContainer, import interrupted.')


def _importFeatureXml(fileLocation):
    """Reads a featureXml file.

    :return: {featureKey1: {attribute1:value1, attribute2:value2, ...}, ...}

    See also :func:`importPeptideFeatures`
    """
    with open(fileLocation, 'r') as openFile:
        readingFeature = False
        readingHull = False
        featureDict = dict()

        for i,line in enumerate(openFile):
            line = line.strip()
            if readingFeature == True:
                if line.find('<convexhull') != -1:
                        readingHull = True
                        hullNr = line.split('<convexhull nr=\"')[1].split('\">')[0]
                        hullList = list()
                elif readingHull == True:
                    if line.find('<pt') != -1:
                        x = float(line.split('x=\"')[1].split('\"')[0])
                        y = float(line.split('y=\"')[1].split('\"')[0])
                        # x = retentiontime, y = m/z
                        #retentionTimeList.append(x)
                        hullList.append([x,y])
                    elif line.find('</convexhull>') != -1:
                        featureDict[featureKey]['convexHullDict'][hullNr] = hullList
                        readingHull = False

                elif line.find('<position dim=\"0\">') != -1:
                    featureDict[featureKey]['dim0'] = float(line.split('<position dim=\"0\">')[1].split('</position>')[0])
                elif line.find('<position dim=\"1\">') != -1:
                    featureDict[featureKey]['dim1'] = float(line.split('<position dim=\"1\">')[1].split('</position>')[0])
                elif line.find('<intensity>') != -1:
                    featureDict[featureKey]['intensity'] = float(line.split('<intensity>')[1].split('</intensity>')[0])
                elif line.find('<overallquality>') != -1:
                    featureDict[featureKey]['overallquality'] = float(line.split('<overallquality>')[1].split('</overallquality>')[0])
                elif line.find('<charge>') != -1:
                    featureDict[featureKey]['charge'] = int( line.split('<charge>')[1].split('</charge>')[0] )

                elif line.find('<userParam') != -1:
                    if line.find('name=\"label\"') != -1:
                        featureDict[featureKey]['label'] = line.split('value=\"')[1].split('\"/>')[0]
                    elif line.find('name=\"score_fit\"') != -1:
                        featureDict[featureKey]['score_fit'] = float(line.split('value=\"')[1].split('\"/>')[0])
                    elif line.find('name=\"score_correlation\"') != -1:
                        featureDict[featureKey]['score_correlation'] = float(line.split('value=\"')[1].split('\"/>')[0])
                    elif line.find('name=\"FWHM\"') != -1:
                        featureDict[featureKey]['FWHM'] = float(line.split('value=\"')[1].split('\"/>')[0])
                    elif line.find('name=\"spectrum_index\"') != -1:
                        featureDict[featureKey]['spectrum_index'] = line.split('value=\"')[1].split('\"/>')[0]
                    elif line.find('name=\"spectrum_native_id\"') != -1:
                        featureDict[featureKey]['spectrum_native_id'] = line.split('value=\"')[1].split('\"/>')[0]

                elif line.find('</feature>') != -1:
                    #mzList = list()
                    #for retentionTime,mz in featureDict[featureKey]['convexHullDict']['0']:
                    #    mzList.append(mz)
                    featureDict[featureKey]['rt'] = featureDict[featureKey]['dim0']#numpy.median(retentionTimeList)
                    featureDict[featureKey]['mz'] = featureDict[featureKey]['dim1']#numpy.median(mzList)

                    readingFeature == False

            if line.find('<feature id') != -1:
                readingFeature = True
                featureKey = line.split('<feature id=\"')[1].split('\">')[0]
                featureDict[featureKey] = dict()
                featureDict[featureKey]['convexHullDict'] = dict()
                #retentionTimeList = list()
    return featureDict
